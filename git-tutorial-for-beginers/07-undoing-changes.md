##Отмена изменений

###Отмена изменений в рабочей директории

Сделаем некоторые изменения в файле **index.html**. Статус git покажет, что данный файл модифицирован:

![](pics/07-01.png)

Представим, что нам не нужно было делать эти изменения, а значит нужно вернуться к старой версии файла. Это можно сделать с помощью команды **`git checkout`**.

Обычно команда **`git checkout`** используется для работы с ветками. Она требует git выполнить следующее: "*Иди в репозиторий, возьми 'нечто' которое я тебе передал в параметрах, и сделай так, чтобы это 'нечто' в рабочей директории выглядело так же как выглядит это 'нечто' в репозитории*". Так что, если "нечто" это ветка, то git выполняет действия над веткой, а если файл – то над файлом.

Чтобы сказать git, что при выполнении команды **`git checkout`** мы хотим работать с файлом, нужно в данной команде поставить две черты, например: **`git checkout -- index.html`**. Это даст git подсказку, что мы хотим работать с файлом **index.html** в текущей ветке, а не с веткой **index.html**. Данной командой мы будто говорим git "*Пойди в репозиторий, в текущую ветку, посмотри как там выглядит файл **index.html** и сделай так, чтобы файл **index.html** в текущей директории выглядел так же*". Выполним эту команду и отменим изменения в указанном файле:

![](pics/07-02.png)

Теперь статус git покажет, что рабочая директория чистая, - она находится в таком же состоянии что и репозиторий:

![](pics/07-03.png)

###Отмена изменений в индексе

Для примера, сделаем некоторые изменения в файле **resources.html** и добавим их в индекс. Статус git:

![](pics/07-04.png)

Чтобы отменить изменения которые уже находятся в индексе, но при этом, чтобы они остались в рабочей директории, для файла **resources.html** необходимо выполнить команду **`git reset HEAD resources.html`**. Эта команда говорит git, чтобы он посмотрел на что указывает **HEAD** (а **HEAD** указывает на последний коммит в текущей ветке), и привёл состояние файла **resources.html** в индексе к такому, которое соответствует состоянию файла **resources.html** на момент последнего коммита.

Выполнение данной процедуры может понадобиться если вы по ошибке добавили в индекс несвязанные между собой изменения файлов, которые хотели бы разбить на два пакета изменений, сделав два коммита.

Выполним команду **`git reset HEAD resources.html`** и отменим добавление изменений в индекс:

![](pics/07-05.png)

Теперь git имеет следующий статус:

![](pics/07-06.png)

###Исправление последнего коммита

Закрепим в индексе изменения сделанные на прошлом шаге и добавим их в репозиторий.

Закрепляем:

![](pics/07-07.png)

Добавляем в репозиторий:

![](pics/07-08.png)

Теперь представим, что мы что-то недоделали, и необходимо добавить правки в пакет изменений входящий в последний коммит. Сделаем необходимые правки. Статус git покажет следующее:

![](pics/07-09.png)

Чтобы добавить сделанные правки в последний коммит, необходимо сначала закрепить их в индексе:

![](pics/07-10.png)

Статус git покажет, что изменения находятся в индексе:

![](pics/07-11.png)

А потом выполнить команду **`git commit`** с ключом  **`--amend`** и необходимым сообщением. Это позволит добавить новые изменения к последнему коммиту:

![](pics/07-12.png)

При этом, в данном случае, сообщение коммита оставлено такое же. Хотя, если сообщение коммита не нужно изменять, то можно воспользоваться командой **`git commit --amend`** без указания сообщения. Откроется редактор по умолчанию с уже введённым предыдущим сообщением.

Лог покажет, что у нас только один коммит с указанным сообщением, так что всё сработало как задумывалось и правки попали в последний коммит:

![](pics/07-13.png)

**Примечание!** Если необходимо изменить только сообщение последнего коммита, например, если в сообщении была допущена опечатка, то можно выполнить команду: **`git commit --amend -m "Новое сообщение"`** или просто **`git commit --amend`**, после чего будет открыт редактор по умолчанию со старым сообщением.

Например, изменение сообщения последнего коммита:

![](pics/07-14.png)

После изменения сообщения, git будет показывать следующий лог:

![](pics/07-15.png)

Как видим, сообщение "Rearrange the items to bring on a trip" было заменено на "Rearrange the items to bring on an outdoor trip".

**Примечание!** При исправлении последнего коммита меняется значение его контрольной суммы, так как она зависит, в том числе, и от сообщения коммита. Именно поэтому можно исправить (**amend**) только последний коммит, в противном случае нарушилась бы целостность данных представляющих дерево коммитов.

###Отмена изменений

Может произойти так, что внесённые изменения в проект оказались неправильными, и необходимо отменить эти изменения, при этом сохранив всё это в истории git, например как напоминание о том, как не нужно делать (подсказка, что данным способом проблему не рашить и т.п.).

**Первый способ отменить изменения** это вручную сделать изменения отменяющие предыдущие изменения и сделать новый коммит.

###Отмена изменений с помощью **`git checkout`**

**Второй способ отменить изменения** это отменить их с помощью git. Например, представим, что нам необходимо отменить изменения в файле **resources.html**, вошедшие в коммит "Rearrange the items to bring on an outdoor trip" с контрольной суммой **5625b5b...**, - вернувшись к состоянию файла **resources.html** такому, которое было на момент когда последним коммитом был коммит "Removed contractions from contact page text" с контрольной суммой **4d55091...**. Для этого необходимо выполнить команду: **`git checkout 4d55091 -- resources.html`**

![](pics/07-16.png)

После выполнения команды состояние файла **resources.html** изменится. В индексе его состояние станет таким, как было на момент коммита с контрольной суммой **4d55091...**. Статус git сообщает о том, что изменения файла **resources.html** находятся в индексе:

![](pics/07-17.png)

Если посмотреть разницу между индексом и репозиторием, то результат будет следующим:

![](pics/07-18.png)

Видно какие строки будут удалены, а какие добавлены – именно это и нужно сделать, чтобы файл принял первоначальное состояние (состояние перед реорганизацией списка).

Теперь если сделать коммит, то мы вернём состояние файла **resources.html** в репозитории к первоначальному. Для написания сообщения коммита, который устраняет некоторые изменения в другом коммите, хорошей практикой является указывать контрольную сумму устраняемого коммита.

Чтобы продолжить обучение, вернёмся к состоянию репозитория, которое было до начала отмены изменений.

Вначале выполним команду **`git reset HEAD resource.html`**, - это вернёт изменения из индекса в рабочую директорию:

![](pics/07-19.png)

Сейчас статус репозитория следующий:

![](pics/07-20.png)

И выполним команду **`git checkout -- resource.html`**, - это вернёт состояние файла **resource.html** в рабочей директории к такому же, как и в репозитории:

![](pics/07-21.png)

Теперь статус git покажет следующее (вернулись в состояние на момент начала урока):

![](pics/07-22.png)

###Отмена коммита

Чтобы отменить все изменения входящие к конкретный коммит, можно использовать команду **`git revert`**. Выполним команду **`git revert HASH`** (где **HASH** – контрольная сумма отменяемого коммита, в конкретном примере это последний коммит с контрольной суммой **5625b5b...**):

![](pics/07-23.png)

Во время выполнения команды **`git revert HASH`** откроется редактор по умолчанию с требованием ввести сообщение для создаваемого отменяющего коммита (можно оставить сообщение по умолчанию, созданное git, оно достаточно точно описывает проделываемое действие):

![](pics/07-24.png)

После этих действий рабочая директория и индекс остаются чистыми:

![](pics/07-25.png)

А лог git-а покажет новый коммит:

![](pics/07-26.png)

**Примечание!** Если делать **revert** не последнего коммита, а например, предпоследнего, то с большой вероятностью может возникнуть ошибка **revert**-a из-за возникшего конфликта между версиями файлов. Чтобы пройти путь без конфликтов, можно возвращаться по одному коммиту назад, хотя при этом каждый раз создаются новые коммиты (**revert**-коммиты). Но только если приемлемо возвращение по одному коммиту назад, так как это будет отменять каждый из коммитов. А при **revert**-е определённого коммита, через конфликт, можно добиться отмены изменений заключённых только в конкретном коммите.

###Отмена множества коммитов

Отменить множество коммитов (цепочку коммитов начиная от последнего) можно с помощью команды **`git revert`**. Эта команда переставляет указатель **HEAD** на требуемый коммит.

Обычно git самостоятельно управляет указателем **HEAD**, это происходит когда мы делаем коммит, в это время git переставляет указатель **HEAD** на новый/последний коммит. А командой **`git reset`** мы говорим git, что сами хотим управлять указателем **HEAD** и поставить его на определённый коммит.

У данной команды есть три ключа, которые управляют состоянием рабочей директории и индекса: ключ **`--soft`**, ключ **`--mixed`** и ключ **`--hard`**.

- Команда **`git reset --soft`** переставляет указатель **HEAD**, при этом не изменяя индекс и рабочую директорию.

- Команда **`git reset --mixed`**, передвигает указатель **HEAD**, при этом изменяет индекс, чтобы он соответствовал репозиторию, но не изменяет рабочую директорию. Ключ **`--mixed`** является ключом по умолчанию.

- Команда **`git reset --hard`** передвигает указатель **HEAD**, при этом изменяет индекс и рабочую директорию так, чтобы они соответствовали репозиторию.

####Использование команды **`git reset --soft`**

Предположим нам необходимо откатиться к состоянию, которое было до выполнения команды **`git revert`** из урока выше. А именно, к состоянию коммита "Rearrange the items to bring on an outdoor trip" с контрольной суммой **5625b5b...**:

![](pics/07-27.png)

**Примечание!** Перед выполнением команды **`git reset`** всегда рекомендуется сохранить в текстовом файле структуру верхних коммитов из лога, для того чтобы, при необходимости, можно было вернуться на самый последний коммит или какой-либо другой, потому что при дальнейшем использовании команды **`git log`** больше не будут показываться коммиты находящиеся за указателем **HEAD**.

Посмотрим, на какой коммит указывает **HEAD** сейчас:

![](pics/07-28.png)

Как видим, **HEAD** указывает на коммит с контрольной суммой **9e7110d39a408a14c62ce7c2d8feec42c8e296dc** – сейчас это верхушка коммитов и самый последний коммит.

Выполнив команду **`git reset --soft`** передвинем указатель **HEAD** на предпоследний коммит "Rearrange the items to bring on an outdoor trip" с контрольной суммой **5625b5b...**:

![](pics/07-29.png)

Как видим, теперь **HEAD** указывает на коммит с контрольной суммой **5625b5b...**:

![](pics/07-30.png)

И команда **`git log --oneline`** также показывает, что верхушкой коммитов является коммит с контрольной суммой **5625b5b...**:

![](pics/07-31.png)

Хотя, как мы понимаем, сейчас верхушкой является не последний из созданных коммитов.

Статус git показывает, что последние изменения в фале **resource.html** присутствуют в индексе (но их уже нет в репозитории, - в репозитории состояние файлов такое, как было на момент коммита **5625b5b...**):

![](pics/07-32.png)

Если необходимо, командой **`git diff --staged`** можно просмотреть разницу между состоянием индекса и репозитория:

![](pics/07-33.png)

При необходимости, сейчас можно сделать коммит. Этот коммит запишется поверх старого коммита "Revert 'Rearrange the items to bring on an outdoor trip'" с контрольной суммой **9e7110d...**. Или же, чтобы вернуть всё назад, можно просто передвинуть указатель **HEAD** на прежний коммит **9e7110d...**, т.к. пока не сделали новый коммит, он существует. Сделаем это:

![](pics/07-34.png)

Лог git покажет следующее:

![](pics/07-35.png)

Статус git покажет, что рабочая директория чистая:

![](pics/07-36.png)

####Использование команды **`git reser --mixed`**

Как и в прошлом уроке, предположим, что нам необходимо откатиться к состоянию коммита "Rearrange the items to bring on an outdoor trip" с контрольной суммой **5625b5b...**:

![](pics/07-37.png)

Команда **`git reset`** с ключом **`--soft`** ничего не выводила, а с ключом **`--mixed`** будет сообщать, что после выполнения команды появились неиндексированные (незакреплённые) изменения.

![](pics/07-38.png)

**M** от **modified**, модифицированный файл **resources.html**.

Статус git покажет неотслеживаемые/неиндексированные изменения в файле **resources.html**:

![](pics/07-39.png)

Разница между рабочей директорией и репозиторием представлена результатом команды **`git diff`**:

![](pics/07-40.png)

Разница между выполнением команды **`git reset`** с ключом **`--soft`** от выполнения с ключом **`--mixed`** незначительная, в первом случае изменения сохранены в двух местах (в рабочей директории и в индексе), а во втором случае – в одном месте (только в рабочей директории). Поэтому, и там, и там еще можно восстановить данные.

Такой ход действий может понадобиться, например, чтобы добавить какие-то незначительные изменения к уже существующим (которые уже находятся в коммите) и закоммитить их в одном пакете изменений в новом коммите.

Продолжая дальше, вернёмся к коммиту "Revert 'Rearrange the items to bring on an outdoor trip'" с контрольной суммой **9e7110d...**, переставив на него указатель **HEAD**. Заметим, что это можно сделать, так как мы ещё не делали никаких новых коммитов:

![](pics/07-41.png)

####Использование команды **`git reser --hard`**

Как и в прошлых двух уроках, предположим, нам необходимо откатиться к состоянию коммита "Rearrange the items to bring on an outdoor trip" с контрольной суммой **5625b5b...**.

Выполним команду **`git reset --hard`**, и сразу же получаем сообщение о том, что указатель **HEAD** ссылается на коммит **5625b5b...**:

![](pics/07-42.png)

Лог git выводит ожидаемый результат:

![](pics/07-43.png)

А статус git, как видим, показывает, что рабочая директория и индекс без каких-либо изменений:

![](pics/07-44.png)

При этом, всё же прежние коммиты остаются на своих местах и ещё можно возвратиться к первоначальному состоянию, к коммиту **9e7110d...** (если есть контрольные суммы необходимых коммитов). Переставим указатель **HEAD** назад, на коммит **9e7110d...**:

![](pics/07-45.png)

Теперь, передвинем указатель **HEAD** на коммит "Removed contractions from contact page text" с контрольной суммой **4d55091...**, чтобы вернутся к тому состоянию, когда ещё не делали реорганизацию списка:

![](pics/07-46.png)

Сделаем немного другую перестановку в списке, - это покажет команда **`git diff`**:

![](pics/07-47.png)

Сохраним изменения в индекс и сразу же в репозиторий:

![](pics/07-48.png)

Теперь лог покажет новую структуру коммитов:

![](pics/07-49.png)

**Замечание!** После этого, в принципе, всё ещё можно вернуться к коммиту "Rearrange the items to bring on an outdoor trip" с контрольной суммой **5625b5b...**, и даже сделать слияние с "веткой", представляющей собой ответвление к коммиту **5625b5b...**, выполнив команду **`git merge 5625b5b`**, но это может вызвать конфликт слияния, и вообще, так делать не рекомендуется.

###Удаление неотслеживаемых файлов

Представим, что в рабочей директории во время выполнения программы были созданы некоторые файлы (например, логи), то чтобы не удалять их вручную, можно воспользоваться командой **`git clean`**.

Для примера, создадим несколько файлов в рабочей директории. Статус git сообщит о них:

![](pics/07-50.png)

Сама по себе команда **`git clean`** ничего не сделает:

![](pics/07-51.png)

А команда **`git clean`** с ключём **`-n`** покажет, какие файлы будут удалены при очистке:

![](pics/07-52.png)

Добавим один файл в индекс, сделав его отслеживаемым, и посмотрим снова на результат команды **`git clean -n`**:

![](pics/07-53.png)

Теперь команда **`git clean`** намерена удалить только два файла. Так получается из-за того, что она удаляет только неотслеживаемые файлы.

Выполним команду **`git clean`** с ключом **`-f`** для удаления заявленных файлов:

![](pics/07-54.png)

Два файла удалены, один остался в индексе:

![](pics/07-55.png)

Теперь, если и первый файл не нужен, то его необходимо убрать из индекса и очистить рабочую директорию.

Удаляем из индекса:

![](pics/07-56.png)

Очищаем рабочую директорию:

![](pics/07-57.png)

Статус git сообщает, что рабочая директория чистая:

![](pics/07-58.png)

Также можно убедиться, что этих файлов нет в рабочей директории:

![](pics/07-59.png)

**Примечание!** Данную команду нужно выполнять с осторожностью, так как удалённые файлы нигде не сохраняются. - Ни в репозитории, ни в индексе, ни в рабочей директории git, ни в рабочей директории проекта, ни в корзине – они пропадают безвозвратно.
